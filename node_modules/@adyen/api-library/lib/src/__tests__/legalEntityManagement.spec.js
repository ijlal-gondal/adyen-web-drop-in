"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const nock_1 = __importDefault(require("nock"));
const client_1 = __importDefault(require("../client"));
const base_1 = require("../__mocks__/base");
const models_1 = require("../typings/legalEntityManagement/models");
const responses_1 = require("../__mocks__/legalEntityManagement/responses");
var TransferEnum = models_1.TransferInstrumentInfo.TypeEnum;
var TypeEnum = models_1.LegalEntityInfo.TypeEnum;
var DocEnum = models_1.Document.TypeEnum;
const requests_1 = require("../__mocks__/legalEntityManagement/requests");
const legalEntityManagement_1 = __importDefault(require("../services/legalEntityManagement"));
let client;
let legalEntityManagement;
let scope;
beforeEach(() => {
    if (!nock_1.default.isActive()) {
        nock_1.default.activate();
    }
    client = (0, base_1.createClient)();
    scope = (0, nock_1.default)(`${client.config.legalEntityManagementEndpoint}/${client_1.default.LEGAL_ENTITY_MANAGEMENT_API_VERSION}`);
    legalEntityManagement = new legalEntityManagement_1.default(client);
});
afterEach(() => {
    nock_1.default.cleanAll();
});
describe("Legal Entity Management", () => {
    const id = "123456789";
    describe("LegalEntities", () => {
        it("should support POST /legalEntities", async () => {
            scope.post("/legalEntities")
                .reply(200, responses_1.legalEntity);
            const request = {
                type: TypeEnum.Individual,
                individual: undefined
            };
            const response = await legalEntityManagement.LegalEntities.create(request);
            expect(response.id).toBe(id);
            expect(response.type).toBe("individual");
        });
        it("should support GET /legalEntities/{id}", async () => {
            scope.get(`/legalEntities/${id}`)
                .reply(200, responses_1.legalEntity);
            const response = await legalEntityManagement.LegalEntities.retrieve("123456789");
            expect(response.id).toBe(id);
            expect(response.type).toBe("individual");
        });
        it("should support PATCH /legalEntities/{id}", async () => {
            scope.patch(`/legalEntities/${id}`)
                .reply(200, responses_1.legalEntity);
            const request = {
                type: TypeEnum.Individual,
                individual: undefined
            };
            const response = await legalEntityManagement.LegalEntities.update(id, request);
            expect(response.id).toBe(id);
            expect(response.type).toBe("individual");
        });
        it("should support GET /legalEntities/{id}/BusinessLines", async () => {
            scope.get(`/legalEntities/${id}/businessLines`)
                .reply(200, responses_1.businessLines);
            const response = await legalEntityManagement.LegalEntities.listBusinessLines(id);
            expect(response.businessLines).toEqual([{
                    "capability": "receivePayments",
                    "id": "123456789",
                    "industryCode": "123456789",
                    "legalEntityId": "123456789",
                    "salesChannels": ["string"],
                    "sourceOfFunds": {
                        "acquiringBusinessLineId": "string",
                        "adyenProcessedFunds": false,
                        "description": "string",
                        "type": "business"
                    },
                    "webData": [{ "webAddress": "string" }],
                    "webDataExemption": { "reason": "noOnlinePresence" }
                }]);
        });
    });
    describe("Transfer Instruments", () => {
        it("should support POST /transferInstruments", async () => {
            scope.post("/transferInstruments")
                .reply(200, responses_1.transferInstrument);
            const request = {
                type: TransferEnum.BankAccount,
                legalEntityId: id,
                bankAccount: { accountNumber: "string",
                    accountType: "string",
                    bankBicSwift: "string",
                    bankCity: "string",
                    bankCode: "string",
                    bankName: "string",
                    branchCode: "string",
                    checkCode: "string",
                    countryCode: "string",
                    currencyCode: "string",
                    iban: "string"
                }
            };
            const response = await legalEntityManagement.TransferInstruments.create(request);
            expect(response.id).toBe(id);
            expect(response.type).toBe(TransferEnum.BankAccount);
        });
        it("should support GET /transferInstruments/{id}", async () => {
            scope.get(`/transferInstruments/${id}`)
                .reply(200, responses_1.transferInstrument);
            const response = await legalEntityManagement.TransferInstruments.retrieve(id);
            expect(response.id).toBe(id);
            expect(response.type).toBe(TransferEnum.BankAccount);
        });
        it("should support PATCH /transferInstruments/{id}", async () => {
            scope.patch(`/transferInstruments/${id}`)
                .reply(200, responses_1.transferInstrument);
            const request = {
                type: TransferEnum.BankAccount,
                legalEntityId: id,
                bankAccount: { accountNumber: "string",
                    accountType: "string",
                    bankBicSwift: "string",
                    bankCity: "string",
                    bankCode: "string",
                    bankName: "string",
                    branchCode: "string",
                    checkCode: "string",
                    countryCode: "string",
                    currencyCode: "string",
                    iban: "string"
                }
            };
            const response = await legalEntityManagement.TransferInstruments.update(id, request);
            expect(response.id).toBe(id);
            expect(response.type).toBe(TransferEnum.BankAccount);
        });
        it("should support DELETE /transferInstruments/{id}", async () => {
            scope.delete(`/transferInstruments/${id}`)
                .reply(200);
            await legalEntityManagement.TransferInstruments.delete(id);
            expect(200);
        });
    });
    describe("Business Lines", () => {
        it("should support POST /businessLines", async () => {
            scope.post("/businessLines")
                .reply(200, responses_1.businessLine);
            const request = {
                capability: "receivePayments",
                industryCode: id,
                legalEntityId: id
            };
            const response = await legalEntityManagement.BusinessLineService.create(request);
            expect(response.id).toBe(id);
            expect(response.capability).toBe("receivePayments");
            expect(response.industryCode).toBe(id);
            expect(response.legalEntityId).toBe(id);
        });
        it("should support GET /businessLines/{id}", async () => {
            scope.get(`/businessLines/${id}`)
                .reply(200, responses_1.businessLine);
            const response = await legalEntityManagement.BusinessLineService.retrieve(id);
            expect(response.id).toBe(id);
            expect(response.capability).toBe("receivePayments");
        });
        it("should support PATCH /businessLines/{id}", async () => {
            scope.patch(`/businessLines/${id}`)
                .reply(200, responses_1.businessLine);
            const request = {
                capability: "receivePayments",
                industryCode: id,
                legalEntityId: id
            };
            const response = await legalEntityManagement.BusinessLineService.update(id, request);
            expect(response.id).toBe(id);
            expect(response.capability).toBe("receivePayments");
            expect(response.industryCode).toBe(id);
            expect(response.legalEntityId).toBe(id);
        });
    });
    describe("Documents", () => {
        it("should support POST /documents", async () => {
            scope.post("/documents")
                .reply(200, responses_1.document);
            const request = {
                attachments: [{
                        content: "string",
                        contentType: "string",
                        filename: "string",
                        pageName: "string",
                        pageType: "string"
                    }],
                description: "document",
                owner: {
                    "id": "123456789",
                    "type": "passport"
                },
                type: DocEnum.DriversLicense
            };
            const response = await legalEntityManagement.Documents.create(request);
            expect(response.id).toBe(id);
            expect(response.type).toBe(DocEnum.DriversLicense);
            expect(response.owner).toEqual({ id: "123456789", type: "passport" });
        });
        it("should support GET /documents/{id}", async () => {
            scope.get(`/documents/${id}`)
                .reply(200, responses_1.document);
            const response = await legalEntityManagement.Documents.retrieve(id);
            expect(response.id).toBe(id);
            expect(response.type).toBe(DocEnum.DriversLicense);
            expect(response.owner).toEqual({ id: "123456789", type: "passport" });
        });
        it("should support PATCH /documents/{id}", async () => {
            scope.patch(`/documents/${id}`)
                .reply(200, responses_1.document);
            const request = {
                attachments: [{
                        content: "string",
                        contentType: "string",
                        filename: "string",
                        pageName: "string",
                        pageType: "string"
                    }],
                description: "document",
                owner: {
                    "id": "123456789",
                    "type": "passport"
                },
                type: DocEnum.DriversLicense
            };
            const response = await legalEntityManagement.Documents.update(id, request);
            expect(response.id).toBe(id);
            expect(response.type).toBe(DocEnum.DriversLicense);
            expect(response.owner).toEqual({ id: "123456789", type: "passport" });
        });
        it("should support DELETE /documents/{id}", async () => {
            scope.delete(`/documents/${id}`)
                .reply(200);
            await legalEntityManagement.Documents.delete(id);
        });
    });
    describe("OnboardingLinks and Themes", () => {
        it("should support POST /onboardingLinks", async () => {
            scope.post(`/legalEntities/${id}/onboardingLinks`)
                .reply(200, responses_1.onboardingLink);
            const request = requests_1.onboardingLinkInfo;
            const response = await legalEntityManagement.HostedOnboardingPage.create(id, request);
            expect(response.url).toBe("https://your.redirect-url.com");
        });
        it("should support GET /themes", async () => {
            scope.get(`/themes`)
                .reply(200, responses_1.onboardingThemes);
            const response = await legalEntityManagement.HostedOnboardingPage.listThemes();
            expect(response.themes[0].id).toEqual(id);
        });
        it("should support GET /themes/{id}", async () => {
            scope.get(`/themes/${id}`)
                .reply(200, responses_1.onboardingTheme);
            const response = await legalEntityManagement.HostedOnboardingPage.retrieveTheme(id);
            expect(response.id).toBe(id);
        });
    });
});
//# sourceMappingURL=legalEntityManagement.spec.js.map